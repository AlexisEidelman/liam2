1) storage:
   a) .args and .kwargs
   b) specific fields (eg .expr)
2) __init__ signature:
   a) explicit args
   b) *args, **kwargs
3) how to populate __fields__:
   a) manually
   b) from __init__ signature
4) argument evaluation
   a) _eval_args

# arg eval: all except those listed in __no_eval_args__

    __no_eval_args__ = ('expr',) # <- an alternative to this would be to have
    # in AbstractExprCall a "modify_context" method which would do nothing by
    # default. Hmmm, might not be feasible, because I need to change the
    # context to evaluate only *some* arguments (eg expr, not all)

    # for traversal, cache
    __fields__ = ('args', 'kwargs')

    # in fact, I cannot store everything in args only, because of
    # kwargs-only args (like in groupby) but all "normal" arguments (whether
    # they have a default value or not and whether they are **passed as kwargs
    # or not** should be stored in "args"

    __eval_args__ = ('num_periods', 'missing')
    #AND/OR
    __no_eval_args__ = ('expr',)

    def __init__(self, *args, ...)
    OR
    def __init__(self, expr, num_periods=1, missing='auto'):


# OPTION 1
# ========

# storage, usage in the class, traversal, cache: in .args and .kwargs
# __fields__ is computed automatically from .__init__
# => all arguments are stored

# arg eval: all except those listed in __no_eval_args__
# arg_names and kwonlyargnames in NumpyFunction: computed automatically

class Std(NumpyAggregate):
    func_name = 'std'
    np_func = (np.std,)

    def __init__(self, a, axis=a, dtype=b, out=c, ddof=d, filter=e, skip_na=f):
        NumpyAggregate.__init__(self, a, axis, dtype, out, ddof, ...)

class Gini(AbstractExprCall):
    func_name = 'gini'

    def __init__(self, expr, filter=None, skip_na=True):
        # skip_na is not explicitly supported by AbstractExprCall but since
        # it takes *args, **kwargs, it should work
        AbstractExprCall.__init__(self, expr, filter, skip_na)

    def _compute(self, expr, filter, skip_na):
        if skip_na:
            ...
        return ...

class Lag(AbstractExprCall):
    func_name = 'lag'

    __no_eval_args__ = ('expr',)

    def __init__(self, expr, num_periods=1, missing='auto'):
        AbstractExprCall.__init__(self, expr, num_periods, missing)

    def _compute(self, context, expr, num_periods, missing):
        entity = context.entity
        return entity.value_for_period(expr, context.period - num_periods,
                                       context, missing)

# OPTION 2
# ========

# storage, usage in the class, traversal, cache: specific fields (eg .expr)
# __fields__ is computed automatically from .__init__
# => all arguments are stored

# arg eval: all except those listed in __no_eval_args__
# arg_names and kwonlyargnames in NumpyFunction: computed automatically

# for storage, usage in the class, traversal, cache
# __fields__ = ('args', 'kwargs')
# for eval: everything by default
# __no_eval_args__ = ('expr',)
# arg_names and kwonlyargnames in NumpyFunction are computed automatically

class Std(NumpyAggregate):
    func_name = 'std'
    np_func = (np.std,)

    def __init__(self, a, axis=a, dtype=b, out=c, ddof=d, filter=e, skip_na=f):
        NumpyAggregate.__init__(self, a, axis, dtype, out, ddof, ...)

class Lag(AbstractExprCall):
    func_name = 'lag'

    __no_eval_args__ = ('expr',)

    def __init__(self, expr, num_periods=1, missing='auto'):
        AbstractExprCall.__init__(self, expr, num_periods, missing)